/*
 * generated by Xtext 2.12.0
 */
package tr.edu.metu.ceng.megamodel.hypomethod.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.CoherenceLink;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Condition;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.ControlVariables;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.DependentVariables;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Design;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Dispersed;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.EventDescriptor;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Evidence;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Experiment;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Factor;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.FactorLevels;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Goals;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.GuardCondition;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.HypoMethodPackage;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Hypothesis;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.IndependentVariables;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Iteration;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.MechHypothesis;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Mechanism;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Model;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.ModelSection;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.PerformanceMeasure;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Query1;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Query2;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Query3;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Reaction;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Response;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Simultaneous;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Values;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.Variables;
import tr.edu.metu.ceng.megamodel.hypomethod.hypoMethod.properties;
import tr.edu.metu.ceng.megamodel.hypomethod.services.HypoMethodGrammarAccess;

@SuppressWarnings("all")
public class HypoMethodSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HypoMethodGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HypoMethodPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HypoMethodPackage.COHERENCE_LINK:
				sequence_CoherenceLink(context, (CoherenceLink) semanticObject); 
				return; 
			case HypoMethodPackage.CONDITION:
				if (rule == grammarAccess.getConditionRule()) {
					sequence_Condition(context, (Condition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTemporalPatternRule()) {
					sequence_Condition_TemporalPattern(context, (Condition) semanticObject); 
					return; 
				}
				else break;
			case HypoMethodPackage.CONTROL_VARIABLES:
				sequence_ControlVariables(context, (ControlVariables) semanticObject); 
				return; 
			case HypoMethodPackage.DEPENDENT_VARIABLES:
				sequence_DependentVariables(context, (DependentVariables) semanticObject); 
				return; 
			case HypoMethodPackage.DESIGN:
				sequence_Design(context, (Design) semanticObject); 
				return; 
			case HypoMethodPackage.DISPERSED:
				sequence_Dispersed(context, (Dispersed) semanticObject); 
				return; 
			case HypoMethodPackage.EVENT_DESCRIPTOR:
				sequence_EventDescriptor(context, (EventDescriptor) semanticObject); 
				return; 
			case HypoMethodPackage.EVIDENCE:
				sequence_Evidence(context, (Evidence) semanticObject); 
				return; 
			case HypoMethodPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case HypoMethodPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case HypoMethodPackage.FACTOR_LEVELS:
				sequence_FactorLevels(context, (FactorLevels) semanticObject); 
				return; 
			case HypoMethodPackage.GOALS:
				sequence_Goals(context, (Goals) semanticObject); 
				return; 
			case HypoMethodPackage.GUARD_CONDITION:
				sequence_GuardCondition(context, (GuardCondition) semanticObject); 
				return; 
			case HypoMethodPackage.HYPOTHESIS:
				sequence_Hypothesis(context, (Hypothesis) semanticObject); 
				return; 
			case HypoMethodPackage.INDEPENDENT_VARIABLES:
				sequence_IndependentVariables(context, (IndependentVariables) semanticObject); 
				return; 
			case HypoMethodPackage.ITERATION:
				sequence_Iteration(context, (Iteration) semanticObject); 
				return; 
			case HypoMethodPackage.MECH_HYPOTHESIS:
				sequence_MechHypothesis(context, (MechHypothesis) semanticObject); 
				return; 
			case HypoMethodPackage.MECHANISM:
				sequence_Mechanism(context, (Mechanism) semanticObject); 
				return; 
			case HypoMethodPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case HypoMethodPackage.MODEL_SECTION:
				sequence_ModelSection(context, (ModelSection) semanticObject); 
				return; 
			case HypoMethodPackage.PERFORMANCE_MEASURE:
				sequence_PerformanceMeasure(context, (PerformanceMeasure) semanticObject); 
				return; 
			case HypoMethodPackage.QUERY1:
				sequence_Query1(context, (Query1) semanticObject); 
				return; 
			case HypoMethodPackage.QUERY2:
				sequence_Query2(context, (Query2) semanticObject); 
				return; 
			case HypoMethodPackage.QUERY3:
				sequence_Query3(context, (Query3) semanticObject); 
				return; 
			case HypoMethodPackage.REACTION:
				sequence_Reaction(context, (Reaction) semanticObject); 
				return; 
			case HypoMethodPackage.RESPONSE:
				sequence_Response(context, (Response) semanticObject); 
				return; 
			case HypoMethodPackage.SIMULTANEOUS:
				sequence_Simultaneous(context, (Simultaneous) semanticObject); 
				return; 
			case HypoMethodPackage.VALUES:
				sequence_Values(context, (Values) semanticObject); 
				return; 
			case HypoMethodPackage.VARIABLES:
				sequence_Variables(context, (Variables) semanticObject); 
				return; 
			case HypoMethodPackage.PROPERTIES:
				sequence_properties(context, (properties) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CoherenceLink returns CoherenceLink
	 *
	 * Constraint:
	 *     (coherence=Coherence hyp+=ID* evi+=ID*)
	 */
	protected void sequence_CoherenceLink(ISerializationContext context, CoherenceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (condition=Event lo=LinkOperators? e=Event? exp1=Expression? v=rangeValue?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalPattern returns Condition
	 *
	 * Constraint:
	 *     (
	 *         condition=Event 
	 *         lo=LinkOperators? 
	 *         e=Event? 
	 *         exp1=Expression? 
	 *         v=rangeValue? 
	 *         l2+=Links* 
	 *         exp+=Expression* 
	 *         (op1+=Temporal | op2+=Logical)* 
	 *         l3=Links?
	 *     )
	 */
	protected void sequence_Condition_TemporalPattern(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ControlVariables returns ControlVariables
	 *
	 * Constraint:
	 *     (controlName=ID controlType=VariableType controlValue=Values)+
	 */
	protected void sequence_ControlVariables(ISerializationContext context, ControlVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DependentVariables returns DependentVariables
	 *
	 * Constraint:
	 *     responseName=Response+
	 */
	protected void sequence_DependentVariables(ISerializationContext context, DependentVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Design returns Design
	 *
	 * Constraint:
	 *     (designType=DesignType? constraint=ID* iteration=Iteration? variables=Variables)
	 */
	protected void sequence_Design(ISerializationContext context, Design semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Dispersed
	 *     Dispersed returns Dispersed
	 *
	 * Constraint:
	 *     disp+=Re+
	 */
	protected void sequence_Dispersed(ISerializationContext context, Dispersed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventDescriptor returns EventDescriptor
	 *
	 * Constraint:
	 *     (eventName=ID event=STRING)
	 */
	protected void sequence_EventDescriptor(ISerializationContext context, EventDescriptor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.EVENT_DESCRIPTOR__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.EVENT_DESCRIPTOR__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.EVENT_DESCRIPTOR__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.EVENT_DESCRIPTOR__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventDescriptorAccess().getEventNameIDTerminalRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getEventDescriptorAccess().getEventSTRINGTerminalRuleCall_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Evidence returns Evidence
	 *
	 * Constraint:
	 *     (eName=ID query+=TemporalPattern* objOfStudy=rangeValue)
	 */
	protected void sequence_Evidence(ISerializationContext context, Evidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentOntology returns Experiment
	 *     Experiment returns Experiment
	 *
	 * Constraint:
	 *     (expName=ID expDesign=Design perfMeasure=PerformanceMeasure)
	 */
	protected void sequence_Experiment(ISerializationContext context, Experiment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__EXP_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__EXP_NAME));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__EXP_DESIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__EXP_DESIGN));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__PERF_MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.EXPERIMENT__PERF_MEASURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExperimentAccess().getExpNameIDTerminalRuleCall_1_0(), semanticObject.getExpName());
		feeder.accept(grammarAccess.getExperimentAccess().getExpDesignDesignParserRuleCall_4_0(), semanticObject.getExpDesign());
		feeder.accept(grammarAccess.getExperimentAccess().getPerfMeasurePerformanceMeasureParserRuleCall_7_0(), semanticObject.getPerfMeasure());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FactorLevels returns FactorLevels
	 *
	 * Constraint:
	 *     (facName=ID l=factorLevelValue? (l1=Levels l2=Levels start1=rangeValue end1=rangeValue)?)
	 */
	protected void sequence_FactorLevels(ISerializationContext context, FactorLevels semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (factorName=ID factorType=VariableType? factorType1=ID? factorValue=Values? factorProperties+=properties*)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentOntology returns Goals
	 *     Goals returns Goals
	 *
	 * Constraint:
	 *     (objOfStudy=STRING purpose=STRING focus=STRING viewPoint=STRING context=STRING)
	 */
	protected void sequence_Goals(ISerializationContext context, Goals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.GOALS__OBJ_OF_STUDY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.GOALS__OBJ_OF_STUDY));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.GOALS__PURPOSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.GOALS__PURPOSE));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.GOALS__FOCUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.GOALS__FOCUS));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.GOALS__VIEW_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.GOALS__VIEW_POINT));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.GOALS__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.GOALS__CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoalsAccess().getObjOfStudySTRINGTerminalRuleCall_6_0(), semanticObject.getObjOfStudy());
		feeder.accept(grammarAccess.getGoalsAccess().getPurposeSTRINGTerminalRuleCall_9_0(), semanticObject.getPurpose());
		feeder.accept(grammarAccess.getGoalsAccess().getFocusSTRINGTerminalRuleCall_12_0(), semanticObject.getFocus());
		feeder.accept(grammarAccess.getGoalsAccess().getViewPointSTRINGTerminalRuleCall_15_0(), semanticObject.getViewPoint());
		feeder.accept(grammarAccess.getGoalsAccess().getContextSTRINGTerminalRuleCall_18_0(), semanticObject.getContext());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GuardCondition returns GuardCondition
	 *
	 * Constraint:
	 *     (gd='[' condition1=ID? link=LinkOperators? condition2=ID?)
	 */
	protected void sequence_GuardCondition(ISerializationContext context, GuardCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentOntology returns Hypothesis
	 *     Hypothesis returns Hypothesis
	 *
	 * Constraint:
	 *     (mechHypothesis+=MechHypothesis* evidences+=Evidence* coherenceLinks+=CoherenceLink* relHypothesis+=RelationalQuery*)
	 */
	protected void sequence_Hypothesis(ISerializationContext context, Hypothesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IndependentVariables returns IndependentVariables
	 *
	 * Constraint:
	 *     variables+=FactorLevels+
	 */
	protected void sequence_IndependentVariables(ISerializationContext context, IndependentVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Iteration returns Iteration
	 *
	 * Constraint:
	 *     iterations=INT
	 */
	protected void sequence_Iteration(ISerializationContext context, Iteration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.ITERATION__ITERATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.ITERATION__ITERATIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIterationAccess().getIterationsINTTerminalRuleCall_4_0(), semanticObject.getIterations());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MechHypothesis returns MechHypothesis
	 *
	 * Constraint:
	 *     (mName=ID assoMech+=TemporalPattern* mechanisticHypothesis=ID?)
	 */
	protected void sequence_MechHypothesis(ISerializationContext context, MechHypothesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mechanism returns Mechanism
	 *
	 * Constraint:
	 *     (mechanismName=ID LHS=Reaction condition=GuardCondition? RHS=Reaction)
	 */
	protected void sequence_Mechanism(ISerializationContext context, Mechanism semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentOntology returns ModelSection
	 *     ModelSection returns ModelSection
	 *
	 * Constraint:
	 *     (modName=ID mechanisms+=Mechanism* events+=EventDescriptor* parameters+=Factor*)
	 */
	protected void sequence_ModelSection(ISerializationContext context, ModelSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=ExperimentOntology+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PerformanceMeasure returns PerformanceMeasure
	 *
	 * Constraint:
	 *     (expectedResponse=ID er=rangeValue std=rangeValue)
	 */
	protected void sequence_PerformanceMeasure(ISerializationContext context, PerformanceMeasure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__EXPECTED_RESPONSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__EXPECTED_RESPONSE));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__ER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__ER));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__STD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.PERFORMANCE_MEASURE__STD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getExpectedResponseIDTerminalRuleCall_1_0(), semanticObject.getExpectedResponse());
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getErRangeValueTerminalRuleCall_3_0(), semanticObject.getEr());
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getStdRangeValueTerminalRuleCall_5_0(), semanticObject.getStd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationalQuery returns Query1
	 *     Query1 returns Query1
	 *
	 * Constraint:
	 *     (
	 *         factor=ID? 
	 *         control=ID? 
	 *         x=rangeValue? 
	 *         (start1=rangeValue end1=rangeValue)? 
	 *         response=ID 
	 *         y=rangeValue? 
	 *         (start2=rangeValue end2=rangeValue)?
	 *     )
	 */
	protected void sequence_Query1(ISerializationContext context, Query1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalQuery returns Query2
	 *     Query2 returns Query2
	 *
	 * Constraint:
	 *     (
	 *         function1=Function? 
	 *         response1=ID? 
	 *         factor1=ID? 
	 *         function2=Function? 
	 *         response2=ID? 
	 *         factor2=ID?
	 *     )
	 */
	protected void sequence_Query2(ISerializationContext context, Query2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalQuery returns Query3
	 *     Query3 returns Query3
	 *
	 * Constraint:
	 *     (
	 *         (factor1=ID | control1=ID | Level2=Levels | x2=rangeValue)* 
	 *         (response1=ID Level4=Levels? x4=rangeValue?)* 
	 *         (
	 *             level=Levels 
	 *             factor=ID? 
	 *             control=ID? 
	 *             response=ID? 
	 *             start1=rangeValue 
	 *             end1=rangeValue
	 *         )*
	 *     )
	 */
	protected void sequence_Query3(ISerializationContext context, Query3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Reaction returns Reaction
	 *
	 * Constraint:
	 *     (agent1=ID agent=ID?)
	 */
	protected void sequence_Reaction(ISerializationContext context, Reaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Response returns Response
	 *
	 * Constraint:
	 *     (responseName=ID responseType=ResponseType)
	 */
	protected void sequence_Response(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.RESPONSE__RESPONSE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.RESPONSE__RESPONSE_NAME));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.RESPONSE__RESPONSE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.RESPONSE__RESPONSE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResponseAccess().getResponseNameIDTerminalRuleCall_0_0(), semanticObject.getResponseName());
		feeder.accept(grammarAccess.getResponseAccess().getResponseTypeResponseTypeEnumRuleCall_3_0(), semanticObject.getResponseType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Simultaneous
	 *     Simultaneous returns Simultaneous
	 *
	 * Constraint:
	 *     (sim1=Re (log+=Logical sim2+=Re)*)
	 */
	protected void sequence_Simultaneous(ISerializationContext context, Simultaneous semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Values returns Values
	 *
	 * Constraint:
	 *     (
	 *         (fVal=ID ((function=STRING fvalue=factorLevelValue) | fvalue=factorLevelValue)) | 
	 *         (((fVal=ID function=STRING) | function=STRING)? value=rangeValue fvalue=factorLevelValue) | 
	 *         (function=STRING fvalue=factorLevelValue) | 
	 *         fvalue=factorLevelValue
	 *     )?
	 */
	protected void sequence_Values(ISerializationContext context, Values semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variables returns Variables
	 *
	 * Constraint:
	 *     (independentVariables=IndependentVariables controlVariables=ControlVariables? dependentVariables=DependentVariables)
	 */
	protected void sequence_Variables(ISerializationContext context, Variables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     properties returns properties
	 *
	 * Constraint:
	 *     (pName=ID pVal=Values)
	 */
	protected void sequence_properties(ISerializationContext context, properties semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.PROPERTIES__PNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.PROPERTIES__PNAME));
			if (transientValues.isValueTransient(semanticObject, HypoMethodPackage.Literals.PROPERTIES__PVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HypoMethodPackage.Literals.PROPERTIES__PVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertiesAccess().getPNameIDTerminalRuleCall_0_0(), semanticObject.getPName());
		feeder.accept(grammarAccess.getPropertiesAccess().getPValValuesParserRuleCall_2_0(), semanticObject.getPVal());
		feeder.finish();
	}
	
	
}
