grammar tr.edu.metu.ceng.megamodel.sedml.Sedml with org.eclipse.xtext.common.Terminals

generate sedml "http://www.ceng.metu.edu.tr/~e1774785/megamodel/sedml"

sedML:
	version=INT level=INT listOfHypotheses=listOfHypotheses (listOfSimulations=listOfSimulations)
	listOfModels=listOfModels listOfTasks=listOfTasks listOfDataGenerators=listOfDataGenerators
	listOfOutputs=listOfOutputs;

listOfHypotheses:
	'listOfHypotheses'
	'{'
	(hypothesis+=hypothesis)*
	'}';

hypothesis:
	'hypotheses'
	'{'
	('mechanistic' 'hypotheses' '{'
	(mechHypothesis+=MechHypothesis)*
	'}')?
	('evidence' '{'
	(evidences+=Evidence)*
	'}')?
	('coherence' 'model' '{'
	(coherenceLinks+=CoherenceLink)*
	'}')?
	('relational' 'hypotheses' '{'
	(relHypothesis+=RelationalQuery)*
	'}')? '}';

RelationalQuery:
	Query1 | Query2 | Query3;

Query1:
	'if' (factor=ID)? (control=ID)? 'is' (x=rangeValue)?
	('added')? ('removed')? ('in the range' start1=rangeValue 'to' end1=rangeValue)?
	'then' (response=ID) 'is' (y=rangeValue)? ('in the range' start2=rangeValue 'to' end2=rangeValue)?;

Query2:
	'compare' (function1=Function)? (response1=ID)? (factor1=ID)? 'and'
	(function2=Function)? (response2=ID)? (factor2=ID)?;

enum Function:
	MIN | MAX | EXP | INVERSE | SIN | COS | TAN | FACTORIAL | LOG;

terminal rangeValue:
	INT ('.')? (INT)?;

enum Levels:
	HIGH | MEDIUM | LOW;

Query3:
	'if' ((factor1=ID)? (control1=ID)? 'is' ('at' 'level' (Level2=Levels))? (x2=rangeValue)? ('and')?)*
	'then' ((response1=ID) 'is' ('at' 'level' (Level4=Levels))? (x4=rangeValue)? ('and')?)*
	'where' ((level=Levels) 'for' (factor=ID)? (control=ID)? (response=ID)?
	'is' 'in the range' (start1=rangeValue) 'to' (end1=rangeValue))*;

CoherenceLink:
	(coherence=Coherence) '(' (hyp+=ID)* ')' '(' ((evi+=ID))* ')';

MechHypothesis:
	(mName=ID) ':' (assoMech+=TemporalPattern)* (mechanisticHypothesis=ID)?;

Evidence:
	(eName=ID) ':' (query+=TemporalPattern)*
	'activation' 'weight' ':' (objOfStudy=rangeValue);

TemporalPattern:
	Condition ((l2+=Links)?)* ((exp+=Expression)?)* ((op1+=Temporal | op2+=Logical)?)* (l3=Links)?;

Condition:
	condition=Event (lo=LinkOperators)? (e=Event)? (exp1=Expression)? (v=rangeValue)?;

enum Expression:
	TRUE | FALSE;

LinkOperators:
	'+' | '-' | '*' | '/' | '%' | ' = ' | ' == ' | '&&' | '||' | '<' | '<=' | '>' | '>=' | '!' | '!=';

Event:
	Dispersed | Simultaneous;

Simultaneous:
	'['
	sim1=Re (log+=Logical sim2+=Re)*
	']';

Dispersed:
	(disp+=Re)+;

Re:
	ID ('(' (ID ID)? ')')?;

enum Links:
	is | occurs | to | in;

enum Temporal:
	precedes | between | eventually | always | before | after | until | never | leads | absent | exists;

enum Logical:
	and | or | not;

enum Coherence:
	EXPLAIN | ANALOGOUS | DATA | CONTRADICT;

listOfModels:
	'listOfModels'
	'{'
	(model+=model)*
	'}';

model:
	'model' '{'
	'id' ':' (id=ID)
	'language' ':' (language=STRING)
	'source' ':' (source=STRING)
	'name' ':' (name=STRING)
	'}';

dataGenerator:
	'dataGenerator' '{'
	'id' ':' (id=ID)
	'name' ':' (name=STRING)
	(listOfVariables=listOfVariables)?
	(math=math)?
	'}';

listOfVariables:
	'listOfDataVariables'
	'{'
	(variable+=variable)*
	'}';

variable:
	'variable' '{'
	'id' ':' (id=ID)
	'target' ':' (target=STRING)
	'taskReference' ':' (taskReference=task)
	'symbol' ':' (symbol=STRING)
	'}';

listOfTasks:
	'listOfTasks'
	'{'
	(task+=task)*
	'}';

task:
	'task' '{'
	'id' ':' (id=ID)
	'modelReference' ':' (modelReference=model)
	'simulationReference' ':' (simulationReference=uniformTimeCourse)
	'name' ':' (name=STRING)
	'}';

listOfDataGenerators:
	'listOfDataGenerators'
	'{'
	(datagenerator+=dataGenerator)*
	'}';

math:
	'math' '{'
	'xlms' ':' (xlms=STRING)
	'}';

listOfOutputs:
	'listOfOutputs'
	'{'
	(plot2D+=plot2D)*
	'}';

plot2D:
	'plot2D' '{'
	'id' ':' (id=ID)
	'name' ':' (name=STRING)
	(listOfCurves=listOfCurves)
	'}';

listOfCurves:
	'listOfCurves'
	'{'
	(curve+=curve)*
	'}';

curve:
	'curve' '{'
	'id' ':' (id=ID)
	'logX' ':' (logX=STRING)
	'logY' ':' (logY=STRING)
	'xDataReference' ':' (xDataReference=STRING)
	'yDataReference' ':' (yDataReference=STRING)
	'}';

listOfSimulations:
	'listOfSimulations'
	'{'
	(uniformTimeCourse+=uniformTimeCourse)*
	'}';

uniformTimeCourse:
	'uniformtimecourse' '{'
	'id' ':' (id=ID)
	'initialTime' ':' (initialTime=INT)
	'outputStartTime' ':' (outputStartTime=INT)
	'outputEndTime' ':' (outputEndTime=INT)
	'numberOfPoints' ':' (numberOfPoints=INT)
	(algorithm=algorithm)
	'}';

algorithm:
	'algorithm' '{'
	'kisaoID' ':' (kisaoID=STRING)
	'}';

